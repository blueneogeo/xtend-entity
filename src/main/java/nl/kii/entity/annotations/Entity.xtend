package nl.kii.entity.annotations

import java.util.List
import java.util.Map
import nl.kii.observe.Observable
import nl.kii.reactive.Change
import nl.kii.reactive.EntityList
import nl.kii.reactive.EntityMap
import nl.kii.reactive.Reactive
import nl.kii.reactive.ReactiveObject
import org.eclipse.xtend.lib.macro.Active
import org.eclipse.xtend.lib.macro.TransformationContext
import org.eclipse.xtend.lib.macro.TransformationParticipant
import org.eclipse.xtend.lib.macro.declaration.ClassDeclaration
import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration
import org.eclipse.xtend.lib.macro.declaration.MutableExecutableDeclaration
import org.eclipse.xtend.lib.macro.declaration.MutableFieldDeclaration
import org.eclipse.xtend.lib.macro.declaration.TypeParameterDeclaration
import org.eclipse.xtext.xbase.lib.Procedures.Procedure0
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1

import static org.eclipse.xtend.lib.macro.declaration.Visibility.*

import static extension nl.kii.util.IterableExtensions.*
import static extension nl.kii.util.OptExtensions.*

/**
 * Reactive Objects can be observed for changes and can have change objects applied to them to change them.
 * Annotating a class with the @Reactive active annotation transforms it into a ReactiveObject.
 * 
	<h3>Classes annotated with @Reactive attain the following features:</h3>
	<p>
	<li>extends ReactiveObjectBase
	<li>an empty constructor
	<li>a constructor of only the @Require fields
	<li>a full constructor of all members in order of appearance
	<li>getters and setters for all package fields
	<li>an apply(Change change) method to change the contents of the fields. 
		Changes applied to this object also propagate into the members if the path points deeper into the object tree  
	<li>an onChange[handler] method to observe changes in the fields. 
		Changes inside fields of type Map, List and ReactiveObject are also reported as changes.
	<li>an isValid() method that returns if the @Require fields are set
	<p>
	<h3>The must obey the following rules:</h3>
	<p>
	<li>Supported member types are Boolean, Integer, Long, Float, Double, Date, String and other ReactiveObjects,
	as well as List<T> and Map<String, T>, where T is one of the above types
	<li>Fields that start with _ in the name or that are protected/package/friendly level will not be converted into getters and setters
	<p>
	<h3>Internals</h3>
	<p>
	Classes annotated with @Reactive use the setters for the fields to observe changes. If the fields are set with ReactiveObjects,
	they are observed for internal changes as well. In order to observe containers like Map and List, these types when set are 
	automatically converted to ReactiveList and ReactiveMap.
 */
@Active(EntityProcessor)
annotation Entity {
	boolean reactive = true
}

class EntityProcessor implements TransformationParticipant<MutableClassDeclaration> {
	
	override doTransform(List<? extends MutableClassDeclaration> classes, extension TransformationContext context) {
		
		val reactiveType = Reactive.newTypeReference
		val changeHandlerType = Procedure1.newTypeReference(Change.newTypeReference)
		val stopObservingType = Procedure0.newTypeReference
		
		// will convert these type to their wrapper types for getter and setter methods
		val typeConversions = #{
			'boolean' -> Boolean,
			'int' -> Integer,
			'long' -> Long,
			'float' -> Float,
			'double' -> Double
		}
		
		for(cls : classes) {

			// Set the class
			val clsType = cls.newTypeReference
			cls.extendedClass = ReactiveObject.newTypeReference
			cls.implementedInterfaces = #[Cloneable.newTypeReference]
			
			// determine which fields we create getters and setters for and which are monitored
			
			val getSetFields = cls.declaredFields.filter [
				!static && !volatile && !simpleName.startsWith('_') && !visibility.in(PROTECTED, DEFAULT)
			]
			
			val reactiveFields = getSetFields.filter [
				findAnnotation(Ignore.newTypeReference.type) == null
			]

			val requiredFields = getSetFields.filter [
				findAnnotation(Require.newTypeReference.type) != null
			]
			
			cls.setDocComment('''
				«cls.docComment»
				<p>
				Part of this class source code is autogenerated by the @Reactive active annotation.
				Please see @Reactive and ReactiveObject for more information on ReactiveObjects.
			''')

			// create (empty) listener fields that are filled once someone calls a getter

			for(field : reactiveFields) {
				cls.addField(field.stopObservingFunctionName) [ 
					type = stopObservingType
					visibility = PROTECTED
					transient = true
				]
			}
			
//			// convert maps to entitymaps
//			
//			reactiveFields.filter[ type.simpleName.startsWith('Map') ].forEach [
//				val keyTypeArg = type.actualTypeArguments.get(0)
//				if(!keyTypeArg.isAssignableFrom(String.newTypeReference()))
//					throw new EntityException('Maps in Entities must be of type Map<String, primitive || Entity>')
//				val valueTypeArg = type.actualTypeArguments.get(1)
//				type = EntityMap.newTypeReference(valueTypeArg) 
//			]
//			
//			// convert lists to entitylists
//			
//			reactiveFields.filter[ type.simpleName.startsWith('Map') ].forEach [
//				val typeArg = type.actualTypeArguments.get(0)
//				type = EntityList.newTypeReference(typeArg) 
//			]

			// create empty constructor
			
			cls.addConstructor [
				addClassTypeParameters(cls, context)
				body = ['''
					this.setPublishing(false);
					«cls.classTypeParameterAssignmentCode»
					this.setPublishing(true);
				''']
			]
			
			// create constructor for the required fields if neccessary
			
			if(requiredFields.length > 0) {
				cls.addConstructor [ 
					addClassTypeParameters(cls, context)
					for(field : requiredFields)
						addParameter(field.simpleName, field.type)
					body = ['''
						this.setPublishing(false);
						«cls.classTypeParameterAssignmentCode»
						«FOR field : requiredFields»
						this.set«field.simpleName.toFirstUpper»(«field.simpleName»);
						«ENDFOR»
						this.setPublishing(true);
					''']
				]
			}
			
			// create complete constructor if necessary
			
			if(reactiveFields.length > requiredFields.length ) {
				cls.addConstructor [ 
					addClassTypeParameters(cls, context)
					for(field : reactiveFields)
						addParameter(field.simpleName, field.type)
					body = ['''
						this.setPublishing(false);
						«cls.classTypeParameterAssignmentCode»
						«FOR field : reactiveFields»
							this.set«field.simpleName.toFirstUpper»(«field.simpleName»);
						«ENDFOR»
						this.setPublishing(true);
					''']
				]
			}
			
			// some type checks for maps and listes
			
			for(field : reactiveFields) {
				if(field.type.simpleName.startsWith('List'))
					if(field.type.actualTypeArguments.empty)
						field.addError('Reactive classes may not have untyped Lists')
				if(field.type.simpleName.startsWith('Map'))
					if(field.type.actualTypeArguments.empty)
						field.addError('Reactive classes may not have untyped Maps')
			}
			
			// create the validate method
			
			cls.addMethod('isValid') [
				returnType = 'boolean'.newTypeReference
				body = ['''
					«FOR field : requiredFields»
						if(«field.simpleName»==null) return false;
					«ENDFOR»
					return true;
				''']
			]
			
			// create getters and setters
			
			for(f : getSetFields) {

				cls.addMethod('get' + f.simpleName.toFirstUpper) [
					returnType = typeConversions
						.get(f.type.simpleName)?.newTypeReference
						.or(f.type)
					body = ['''return «f.simpleName»;''']
				]
				
				cls.addMethod('set' + f.simpleName.toFirstUpper) [
					val setterType = typeConversions
						.get(f.type.simpleName)?.newTypeReference
						.or(f.type)
					addParameter('value', setterType)
					body = ['''
						// stop listening to old value
						if(this.«f.simpleName» != null && this.«f.stopObservingFunctionName» != null)
							«f.stopObservingFunctionName».apply();
						// set the value
						this.«f.simpleName» = value;
						// and start observing the new value for changes
						«observeField(f, context)»
						// if we are publishing, publish the change we've made
						if(this.isPublishing()) {
							«IF f.type.primitive || f.type.isAssignableFrom(String.newTypeReference)»
								getPublisher().apply(new Change(nl.kii.reactive.ChangeType.UPDATE, "«f.simpleName»", value));
							«ELSEIF f.type.isAssignableFrom(Map.newTypeReference)»
								getPublisher().apply(new Change(nl.kii.reactive.ChangeType.UPDATE, "«f.simpleName»", ((«f.toEntityMapType(context).name»)this.«f.simpleName»).clone()));
							«ELSEIF f.type.isAssignableFrom(List.newTypeReference)»
								getPublisher().apply(new Change(nl.kii.reactive.ChangeType.UPDATE, "«f.simpleName»", ((«f.toEntityListType(context).name»)this.«f.simpleName»).clone()));
							«ELSE»
								getPublisher().apply(new Change(nl.kii.reactive.ChangeType.UPDATE, "«f.simpleName»", this.«f.simpleName».clone()));
							«ENDIF»
						}
					''']
				]

			}
			
			// create the apply change method

			cls.addMethod('apply') [
				synchronized = true
				addParameter('change', Change.newTypeReference)
				body = ['''
					boolean wasPublishing = this.isPublishing();
					try {
						// do not publish when applying, to prevent update loops
						this.setPublishing(false);
						// determine what to change using the change path
						if(change.getPath() == null || change.getPath().size() == 0) {
							// change applies to this object, check the type
							if(change.getValue() == null)
								throw new NullPointerException("incoming change has no value: " + change);
							if(!(change.getValue() instanceof «clsType.name»)) 
								throw new IllegalArgumentException("incoming change has a value of the wrong type: " + change + ", expected " + this.getClass().getName());
							// assign the all fields directly from the value of the change
							«clsType.name» value = ((«clsType.name»)change.getValue()).clone();
							«FOR field : reactiveFields»
								if(value.«field.simpleName» != null) 
									this.set«field.simpleName.toFirstUpper»(value.«field.simpleName»);
							«ENDFOR»
						} else if(change.getPath().size() == 1) {
							// change applies directly to a field of this object
							String field = change.getPath().get(0);
							«FOR field : reactiveFields»
							if(field.equals("«field.simpleName»")) {
								switch(change.getAction()) {
									case UPDATE:
										this.set«field.simpleName.toFirstUpper»((«field.type.simpleName»)change.getValue());
										// this.«field.simpleName» = («field.type.simpleName»)change.getValue();
										break;
									case CLEAR:
										this.«field.simpleName» = null;
										break;
									default: throw new IllegalArgumentException("cannot update field «field.simpleName» of entity «clsType.simpleName» with " + change + ", must be an UPDATE or CLEAR command");
								}
							}
							«ENDFOR»
						} else {
							// change goes deeper inside of of the fields, propagate the path inside that field
							String field = change.getPath().get(0);
							«FOR field : reactiveFields»
							if(field.equals("«field.simpleName»")) {
								«IF reactiveType.isAssignableFrom(field.type)»
									«field.simpleName».apply(change.forward());
								«ELSE»
									throw new IllegalArgumentException("cannot update field «field.simpleName» of entity «clsType.simpleName» with " + change + ", the field is not Reactive");
								«ENDIF»
							}
							«ENDFOR»
						}
					} finally {
						this.setPublishing(wasPublishing);
					}
				''']
			]
			
			// create a tostring override
			
			cls.addMethod('toString') [
				// addAnnotation(overrideType.)
				val stringType = String.newTypeReference
				returnType = string
				body = ['''
					return "«cls.simpleName» { "
					«FOR field:reactiveFields SEPARATOR ' + ", " '»
						+ "«field.simpleName»: " +
						«IF field.type.isAssignableFrom(stringType)»
							"'" + this.«field.simpleName» + "'" 
						«ELSE»
							this.«field.simpleName» 
						«ENDIF»
					«ENDFOR»
					+ " }";
				''']
			]
			
			// create equals override
			if(!cls.declaredMethods.findFirst[simpleName=='equals'].defined)
				cls.addMethod('equals') [
					//addAnnotation(overrideType.type)
					addParameter('object', object)
					returnType = primitiveBoolean
					body = ['''
						if(object instanceof «cls.simpleName») {
							return (
								«FOR field : getSetFields SEPARATOR ' && '»
									(
										(this.«field.simpleName» == null && ((«cls.simpleName») object).«field.simpleName» == null) ||
										(
											this.«field.simpleName» != null && 
											this.«field.simpleName».equals(((«cls.simpleName») object).«field.simpleName»)
										) 
									)
								«ENDFOR»
							);
						} else return false;
					''']
				]
			
			// create hashcode override
			if(!cls.declaredMethods.findFirst[simpleName=='hashCode'].defined)
				cls.addMethod('hashCode') [
					// addAnnotation(overrideType.type)
					returnType = primitiveInt
					body = ['''
						return (
							«FOR field : getSetFields SEPARATOR ' + '»
								((this.«field.simpleName» != null) ?
								«IF field.type.primitive»
									(this.«field.simpleName» + "").hashCode()
								«ELSE»
									this.«field.simpleName».hashCode()
								«ENDIF»
								: 0)
							«ENDFOR»
						) * 37;
					''']
				]
				
			// create clone override
			if(!cls.declaredMethods.findFirst[simpleName=='clone'].defined)
				cls.addMethod('clone') [
					returnType = clsType
					body = ['''
						try {
							return («clsType.simpleName»)super.clone();
						} catch(CloneNotSupportedException e) {
							return null;
						}
					''']
					
//					// addAnnotation(overrideType.type)
//					docComment = '''
//						Make a copy of the instance.
//						cloning is important for propagating changes, since changes may have no ties to the original object
//					'''
//					returnType = cls.newTypeReference
//					body = ['''
//						«cls.qualifiedName» instance = new «cls.qualifiedName»();
//						«FOR field : getSetFields»
//							if(this.«field.simpleName» != null) {
//								«IF field.type.primitive || field.type.isAssignableFrom(String.newTypeReference)»
//									instance.set«field.simpleName.toFirstUpper»(this.«field.simpleName»);
//								«ELSEIF field.type.isAssignableFrom(Map.newTypeReference)»
//									instance.set«field.simpleName.toFirstUpper»(((«field.toEntityMapType(context).name»)this.«field.simpleName»).clone());
//								«ELSEIF field.type.isAssignableFrom(List.newTypeReference)»
//									instance.set«field.simpleName.toFirstUpper»(((«field.toEntityListType(context).name»)this.«field.simpleName»).clone());
//								«ELSE»
//									instance.set«field.simpleName.toFirstUpper»(this.«field.simpleName».clone());
//								«ENDIF»
//							}
//						«ENDFOR»
//						return instance;
//					''']
				]
			
			// helpers

			cls.addMethod('newChangeHandler') [
				visibility = PROTECTED
				docComment = 'creates a listener for propagating to changes on a field to the publisher'
				addParameter('path', string)
				returnType = changeHandlerType
				body = ['''
					final «clsType.simpleName» entity = this;
					return new Procedure1<Change>() {
						public void apply(Change change) {
							//only propagate a change if we can publish
							if(hasPublisher())
								getPublisher().apply(change.addPath(path));
						}
					};
				''']
			]
			
		}
		
	}

	def observeField(MutableFieldDeclaration f, extension TransformationContext context) '''
		«IF f.type.simpleName.startsWith('List')»
			// if the list is not already reactive, wrap the list as a reactive list
			if(«f.simpleName» == null || !(«f.simpleName» instanceof  nl.kii.reactive.EntityList<?>)) {
				«val typeArg = f.type.actualTypeArguments.get(0)»
				«val listType = EntityList.newTypeReference(typeArg)»
				«listType.name» newList = new «listType.name»(«typeArg.name».class);
				if(«f.simpleName» != null) newList.addAll(«f.simpleName»);
				«f.simpleName» = newList;
				this.«f.getStopObservingFunctionName» = newList.onChange(newChangeHandler("«f.simpleName»"));
			}
		«ELSEIF f.type.simpleName.startsWith('Map')»
			// if the map is not already listenable, wrap the map as a listenable
			if(«f.simpleName» == null || !(«f.simpleName» instanceof  nl.kii.reactive.EntityMap<?>)) {
				«val typeArg = f.type.actualTypeArguments.get(1)»
				«val mapType = EntityMap.newTypeReference(typeArg)»
				«mapType.name» newMap = new «mapType.name»(«typeArg.simpleName».class);
				if(«f.simpleName» != null) newMap.putAll(«f.simpleName»);
				«f.simpleName» = newMap;
				this.«f.getStopObservingFunctionName» = newMap.onChange(newChangeHandler("«f.simpleName»"));
			}
		«ELSEIF Observable.newTypeReference(Change.newTypeReference).isAssignableFrom(f.type)»
			this.«f.getStopObservingFunctionName» = this.«f.simpleName».onChange(newChangeHandler("«f.simpleName»"));
		«ENDIF»
	'''

	def getStopObservingFunctionName(MutableFieldDeclaration field) {
		'stopObserving' + field.simpleName.toFirstUpper + 'Fn'
	}

	def getTypeParamName(TypeParameterDeclaration type, int position) {
		'typeParam' + position
	}
	
	def toEntityMapType(MutableFieldDeclaration field, extension TransformationContext context) {
		EntityMap.newTypeReference(field.type.actualTypeArguments.get(1))
	}
	
	def toEntityListType(MutableFieldDeclaration field, extension TransformationContext context) {
		EntityList.newTypeReference(field.type.actualTypeArguments.get(0))
	}
	
	def addClassTypeParameters(MutableExecutableDeclaration constructor, ClassDeclaration cls, extension TransformationContext context) {
		cls.typeParameters.forEach [ param, count | 
			constructor.addParameter(
				param.getTypeParamName(count + 1), 
				Class.newTypeReference(param.newTypeReference)
			)
		]
	}
	
	def getClassTypeParameterAssignmentCode(ClassDeclaration cls) {
		val List<String> list = newLinkedList
		cls.typeParameters.forEach [ param, count |
			val name = param.getTypeParamName(count + 1)
			list << '''this.«name» = «name»;'''
		]
		list.join('\n')
	}
	
	def getClassTypeParameters(ClassDeclaration cls) {
		val List<String> list = newLinkedList
		cls.typeParameters.forEach [ param, count |
			list << param.getTypeParamName(count + 1)
		]
		list
	}

	
}
